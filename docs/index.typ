#import "lib/gost.typ": init

#show: init

= Цель работы

Изучение методов хеширования данных и
получение практических навыков реализации хеш-таблиц.

= Вариант задания

Составить хеш-функцию в соответствии с заданным вариантом и
проанализировать ее. При необходимости доработать хеш-функцию.
Используя полученную хеш-функцию разработать на языке
программирования высокого уровня программу, которая должна выполнять
следующие функции:
- создавать хеш-таблицу;
- добавлять элементы в хеш-таблицу;
- просматривать хеш-таблицу;
- искать элементы в хеш-таблице по номеру сегмента/по ключу;
- выгружать содержимое хеш-таблицы в файл для построения гистограммы в MS Excel, или в аналогичном подходящем ПО;
- удалять элементы из хеш-таблицы;
- в программе должна быть реализована проверка формата вводимого ключа;
- при удалении элементов из хэш-таблицы, в программе должен быть реализован алгоритм, позволяющий искать элементы, вызвавшие коллизию с удаленным;
- в программе должен быть реализован алгоритм, обрабатывающий ситуации с переполнением хэш-таблицы.

Вариант 25
- Формат ключа: "цБББББ"

  Где «ц» – это цифра 0…9; «Б» – это большая буква латиницы A…Z.
- Количество сегментов: 1500
- Метод хеширования (разрешения коллизий)

= Создание хеш функции

Используя заданный формат ключа "ЦБББББ" и количество сегментов 1500, составил следующую хэш-функцию:

```text
h(key) = (key[2] + key[3] + key[4] + key[5] + key[6]) * (key[1].toInt() + 1)
```

То есть складываем все коды символных значений и умножаем на число, стоящее первым в ключе.
Оценим область определения значения данной функции, взяв минимальные и максимальные значения:

- Минимальные значения:
  Минимальный символ: $"A" = 65 => 5 dot 65 = 325$
  Минимальное число: $0$

  Итого: $325 dot (0 + 1) = 325$

- Максимальные значения:

  $"Z" = 90 => 5 dot 90 = 450$

  Максимальное число $10$

  Итого: $450 dot (10 + 1) = 450 dot 11 = 4960$

Можно заметить что минимальное значение больше 0, а 4960 больше 1500, что не охватывает все сегменты. Всего значений в этом диапозоне $4960 - 325 = 4635$,
что позволяет нам пройти наш сегмент за $~3$ раза и обеспечивает определённую энтропию объектов. Тогда к нашей хэш-функции добавим остаток от деления от числа сегментов:

```text
h(key) = ((key[2] + key[3] + key[4] + key[5] + key[6]) * (key[1].toInt() + 1)) % 1500
```

Теперь проанализируем качество полученной хеш-функции. Для этого
осуществим экспериментальное исследование количества коллизий,
приходящихся на сегменты хеш-таблицы.

Экспериментальное исследование проводится следующим образом:
+ формируются случайным образом ключи заданного формата в
количестве, превышающем количество сегментов хеш-таблицы в
2…3 раза;
+ для каждого сформированного ключа вычисляется хеш-функция, и
подсчитывается, сколько раз вычислялся адрес того или иного
сегмента хеш-таблицы.

На основе сгенерированных 10 000 ключей получаем следующую диаграмму распределения коллизий:

#figure(image("images/001_bad_hash_colls.png"))

Можно заметить, что в этой диаграмме есть всплески, следовательно  разработанная хеш-функция неудачна.
В качестве лучшей реализации хэш-функции реализую полинимальное хэширование. Хэш функция которого выглядит так:

$
  h("key") = ("key"[1] + "key"[2] * p + "key"[3] * p^2 dots + key[6] * p^5)
$

В результате, на оснаве всё тех же 10 000 сгенерированных ключей получаем следующую диаграмму распределения коллизий:

#figure(image("002_my_hash_vs_polynom.png"), caption: "Мое хеширование против полиномиального хеширования")

Анализ этой диаграммы показывает, что коллизии распределены
более равномерно и, следовательно, новую хеш-функцию на можно считать
приемлемой.

= Листинг программы

LinearLinkedList.kt -- особая реализация одностороннего списка.
#raw(read("../src/LinearLinkedList.kt"), lang: "kt", block: true)

HashTable.kt -- интерфейс хеш-таблицы для создания различных реализаций.
#raw(read("../src/HashTable.kt"), lang: "kt", block: true)

BadHashTable.kt -- реализация хеш-таблицы с моим хешированием и без обработки коллизий.
#raw(read("../src/BadHashTable.kt"), lang: "kt", block: true)

GoodHashTable.kt -- реализация хеш-таблицы с биномиальным хешированием с открытым хешированием.
#raw(read("../src/HashTable.kt"), lang: "kt", block: true)

main.kt -- интерактивная программа для работы с хеш-таблицей.
#raw(read("../src/HashTable.kt"), lang: "kt", block: true)


= Скриншоты работы программы

= Выводы

Изучил методы хеширования данных и реализовал рабочую хеш-таблицу.
